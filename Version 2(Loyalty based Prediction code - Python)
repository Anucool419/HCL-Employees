import streamlit as st
import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

# --- PAGE CONFIGURATION ---
st.set_page_config(page_title="Customer Value Predictor", page_icon="üõçÔ∏è", layout="wide")

# --- CUSTOM CSS FOR "HACKATHON" LOOK ---
st.markdown("""
    <style>
    .metric-card {
        background-color: #f0f2f6;
        border-radius: 10px;
        padding: 20px;
        text-align: center;
    }
    .stButton>button {
        width: 100%;
        background-color: #FF4B4B;
        color: white;
    }
    </style>
    """, unsafe_allow_html=True)

# --- CACHED FUNCTIONS (To speed up the app) ---
@st.cache_data
def load_and_process_data(uploaded_file):
    """
    Loads raw data, engineers features, and calculates global metrics.
    Only runs once when the file is uploaded.
    """
    # 1. Load Data
    df = pd.read_csv(uploaded_file)
    df['InvoiceDate'] = pd.to_datetime(df['InvoiceDate'])
    df['Amount'] = df['Quantity'] * df['UnitPrice']

    # 2. Define Split Dates
    train_start = pd.Timestamp('2010-12-01')
    train_end = pd.Timestamp('2011-09-30 23:59:59')
    test_start = pd.Timestamp('2011-10-01')
    test_end = pd.Timestamp('2011-10-31 23:59:59')

    # 3. Helper: Build Dataset (RFM Features)
    def build_dataset_internal(df_full, feature_start, feature_end, target_start, target_end):
        # Features (X)
        mask_X = (df_full['InvoiceDate'] >= feature_start) & (df_full['InvoiceDate'] <= feature_end)
        df_X = df_full.loc[mask_X].copy()
        df_X['YearMonth'] = df_X['InvoiceDate'].dt.to_period('M')

        X = df_X.groupby('CustomerID').agg({
            'InvoiceDate': lambda x: (feature_end - x.max()).days,
            'InvoiceNo': 'nunique',
            'Amount': 'sum',
            'Quantity': 'sum',
            'YearMonth': 'nunique',
        }).rename(columns={'YearMonth': 'MonthsActive', 'InvoiceDate': 'Recency', 
                           'InvoiceNo': 'Frequency', 'Amount': 'Monetary', 'Quantity': 'TotalItems'})

        # Min Monthly Quantity
        monthly_qty = df_X.groupby(['CustomerID', 'YearMonth'])['Quantity'].sum().reset_index()
        min_monthly = monthly_qty.groupby('CustomerID')['Quantity'].min()
        X = X.join(min_monthly.rename('MinMonthlyQuantity'))

        # Target (Y)
        mask_y = (df_full['InvoiceDate'] >= target_start) & (df_full['InvoiceDate'] <= target_end)
        df_y = df_full.loc[mask_y]
        y = df_y.groupby('CustomerID').agg({
            'Amount': 'sum',
            'Quantity': 'sum'
        }).rename(columns={'Amount': 'Target_Spend', 'Quantity': 'Target_Quantity'})

        return X.merge(y, on='CustomerID', how='left').fillna(0)

    # 4. Build Data
    data = build_dataset_internal(df, train_start, train_end, test_start, test_end)

    # 5. Categorization Logic
    def assign_category(row):
        months = row['MonthsActive']
        min_qty = row['MinMonthlyQuantity']
        
        if months == 10: 
            if min_qty >= 50: return 'Diamond'
            elif min_qty >= 30: return 'Gold'
            elif min_qty >= 20: return 'Silver'
            elif min_qty >= 10: return 'Bronze'
            else: return 'Iron'
        elif months >= 7: return 'VJS'
        elif months >= 3: return 'Mr.D'
        elif months >= 1: return 'AK'
        else: return 'Unknown'

    data['Category'] = data.apply(assign_category, axis=1)
    
    return data

def train_models(data):
    """Trains the models and returns them along with metrics."""
    features = ['Recency', 'Frequency', 'Monetary', 'TotalItems']
    X = data[features]
    y_spend = data['Target_Spend']
    y_qty = data['Target_Quantity']

    # Train
    model_spend = LinearRegression()
    model_spend.fit(X, y_spend)
    
    model_qty = LinearRegression()
    model_qty.fit(X, y_qty)

    # Metrics
    preds_spend = model_spend.predict(X)
    metrics = {
        'mae': mean_absolute_error(y_spend, preds_spend),
        'rmse': np.sqrt(mean_squared_error(y_spend, preds_spend)),
        'r2': r2_score(y_spend, preds_spend)
    }
    
    return model_spend, model_qty, metrics, features

# --- MAIN UI LAYOUT ---

st.title("üõçÔ∏è AI Retail Customer Predictor")
st.markdown("Predict 30-day future spend and categorize customers based on purchase history.")

# 1. SIDEBAR: DATA UPLOAD
with st.sidebar:
    st.header("1. Upload Data")
    uploaded_file = st.file_uploader("Upload 'Online_Retail.csv'", type=["csv"])
    
    st.info("System expects columns: InvoiceDate, Quantity, UnitPrice, CustomerID, InvoiceNo")

if uploaded_file is not None:
    # 2. PROCESS DATA (Only runs once)
    with st.spinner("Processing data, engineering features, and training models..."):
        try:
            data = load_and_process_data(uploaded_file)
            model_spend, model_qty, metrics, feature_cols = train_models(data)
            st.success("Model Trained Successfully!")
        except Exception as e:
            st.error(f"Error processing file: {e}")
            st.stop()

    # 3. DISPLAY GLOBAL METRICS
    st.markdown("### üìä Model Performance (Global)")
    col1, col2, col3 = st.columns(3)
    col1.metric("MAE (Error)", f"${metrics['mae']:.2f}")
    col2.metric("RMSE", f"{metrics['rmse']:.2f}")
    col3.metric("R¬≤ Score", f"{metrics['r2']:.4f}")
    st.divider()

    # 4. PREDICTION INTERFACE
    st.header("2. Predict Specific Customer")
    
    # Input ID
    cust_id_input = st.number_input("Enter Customer ID", min_value=1, step=1, value=int(data.index[0]))

    if st.button("Generate Prediction"):
        if cust_id_input in data.index:
            # Fetch Data
            row = data.loc[cust_id_input]
            cust_features = pd.DataFrame([row[feature_cols]])
            
            # Predict
            pred_spend = model_spend.predict(cust_features)[0]
            pred_qty = model_qty.predict(cust_features)[0]
            
            # Logic: Visit Likelihood
            prob = row['MonthsActive'] / 10.0
            visit_likely = (prob >= 0.3 and pred_spend > 0)
            
            # --- DISPLAY RESULTS ---
            st.subheader(f"Results for Customer: {cust_id_input}")
            
            # Top Row: Category & Status
            c1, c2 = st.columns(2)
            with c1:
                st.info(f"**Customer Category:** {row['Category']}")
            with c2:
                if visit_likely:
                    st.success("**Likely to Visit?** YES ‚úÖ")
                else:
                    st.error("**Likely to Visit?** NO ‚ùå")

            # Bottom Row: Numbers
            c3, c4 = st.columns(2)
            c3.metric(label="Predicted 30-Day Spend", value=f"${max(0, pred_spend):.2f}")
            c4.metric(label="Predicted Items (Qty)", value=f"{int(max(0, pred_qty))}")

            # Optional: Show their history for context
            with st.expander("View Customer History"):
                st.dataframe(row)

        else:
            st.warning(f"Customer ID {cust_id_input} not found in the historical training data.")

else:
    st.markdown("""
    <div style='text-align: center; margin-top: 50px;'>
        <h3>‚¨ÖÔ∏è Please upload a CSV file to begin.</h3>
    </div>
    """, unsafe_allow_html=True)




#below is the same approach but with RandomForestRegression
import streamlit as st
import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestRegressor  # <--- FIXED IMPORT
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

# --- PAGE CONFIGURATION ---
st.set_page_config(page_title="Customer Value Predictor", page_icon="üõçÔ∏è", layout="wide")

# --- CUSTOM CSS ---
st.markdown("""
    <style>
    .metric-card {
        background-color: #f0f2f6;
        border-radius: 10px;
        padding: 20px;
        text-align: center;
    }
    .stButton>button {
        width: 100%;
        background-color: #FF4B4B;
        color: white;
    }
    </style>
    """, unsafe_allow_html=True)

# --- CACHED FUNCTIONS ---
@st.cache_data
def load_and_process_data(uploaded_file):
    # 1. Load Data (Handle CSV or Excel)
    if uploaded_file.name.endswith('.csv'):
        df = pd.read_csv(uploaded_file)
    else:
        df = pd.read_excel(uploaded_file) # <--- ADDED EXCEL SUPPORT

    df['InvoiceDate'] = pd.to_datetime(df['InvoiceDate'])
    df['Amount'] = df['Quantity'] * df['UnitPrice']

    # 2. Define Split Dates
    train_start = pd.Timestamp('2010-12-01')
    train_end = pd.Timestamp('2011-09-30 23:59:59')
    test_start = pd.Timestamp('2011-10-01')
    test_end = pd.Timestamp('2011-10-31 23:59:59')

    # 3. Helper: Build Dataset
    def build_dataset_internal(df_full, feature_start, feature_end, target_start, target_end):
        mask_X = (df_full['InvoiceDate'] >= feature_start) & (df_full['InvoiceDate'] <= feature_end)
        df_X = df_full.loc[mask_X].copy()
        df_X['YearMonth'] = df_X['InvoiceDate'].dt.to_period('M')

        X = df_X.groupby('CustomerID').agg({
            'InvoiceDate': lambda x: (feature_end - x.max()).days,
            'InvoiceNo': 'nunique',
            'Amount': 'sum',
            'Quantity': 'sum',
            'YearMonth': 'nunique',
        }).rename(columns={'YearMonth': 'MonthsActive', 'InvoiceDate': 'Recency', 
                           'InvoiceNo': 'Frequency', 'Amount': 'Monetary', 'Quantity': 'TotalItems'})

        # Min Monthly Quantity
        monthly_qty = df_X.groupby(['CustomerID', 'YearMonth'])['Quantity'].sum().reset_index()
        min_monthly = monthly_qty.groupby('CustomerID')['Quantity'].min()
        X = X.join(min_monthly.rename('MinMonthlyQuantity'))

        # Target
        mask_y = (df_full['InvoiceDate'] >= target_start) & (df_full['InvoiceDate'] <= target_end)
        df_y = df_full.loc[mask_y]
        y = df_y.groupby('CustomerID').agg({
            'Amount': 'sum',
            'Quantity': 'sum'
        }).rename(columns={'Amount': 'Target_Spend', 'Quantity': 'Target_Quantity'})

        # Merge
        return X.merge(y, on='CustomerID', how='left').fillna(0)

    # 4. Build Data
    data = build_dataset_internal(df, train_start, train_end, test_start, test_end)

    # 5. Categorization Logic
    def assign_category(row):
        months = row['MonthsActive']
        min_qty = row['MinMonthlyQuantity']
        
        # Note: Your training data is only 10 months long (Dec-Sep), 
        # so 'months == 13' might never happen unless you use a larger dataset.
        if months == 13:  
            if min_qty >= 50: return 'Diamond'
            elif min_qty >= 30: return 'Gold'
            elif min_qty >= 20: return 'Silver'
            elif min_qty >= 10: return 'Bronze'
            else: return 'Iron'
        elif 8 <= months <= 12: return 'VJS'
        elif 4 <= months <= 7: return 'Mr.D' # <--- FIXED LOGIC (Between 4 and 7)
        elif 1 <= months <= 3: return 'AK'
        else: return 'Unknown'

    data['Category'] = data.apply(assign_category, axis=1)
    return data

def train_models(data):
    features = ['Recency', 'Frequency', 'Monetary', 'TotalItems']
    X = data[features]
    y_spend = data['Target_Spend']
    y_qty = data['Target_Quantity']

    model_spend = RandomForestRegressor(n_estimators=100, random_state=42)
    model_spend.fit(X, y_spend)
    
    model_qty = RandomForestRegressor(n_estimators=100, random_state=42)
    model_qty.fit(X, y_qty)

    preds_spend = model_spend.predict(X)
    metrics = {
        'mae': mean_absolute_error(y_spend, preds_spend),
        'rmse': np.sqrt(mean_squared_error(y_spend, preds_spend)),
        'r2': r2_score(y_spend, preds_spend)
    }
    return model_spend, model_qty, metrics, features

# --- MAIN UI LAYOUT ---

st.title("üõçÔ∏è AI Retail Customer Predictor")
st.markdown("Predict 30-day future spend and categorize customers based on purchase history.")

# SIDEBAR
with st.sidebar:
    st.header("1. Upload Data")
    uploaded_file = st.file_uploader("Upload CSV or Excel", type=["csv", "xlsx"])
    st.info("Supported: .csv and .xlsx")

if uploaded_file is not None:
    with st.spinner("Processing data..."):
        try:
            data = load_and_process_data(uploaded_file)
            model_spend, model_qty, metrics, feature_cols = train_models(data)
            st.success("Model Trained Successfully!")
        except Exception as e:
            st.error(f"Error: {e}")
            st.stop()

    # METRICS
    st.markdown("### üìä Model Performance")
    c1, c2, c3 = st.columns(3)
    c1.metric("MAE", f"${metrics['mae']:.2f}")
    c2.metric("RMSE", f"{metrics['rmse']:.2f}")
    c3.metric("R¬≤", f"{metrics['r2']:.4f}")
    st.divider()

    # PREDICTION
    st.header("2. Predict Specific Customer")
    cust_id_input = st.number_input("Enter Customer ID", min_value=1, step=1, value=int(data.index[0]))

    if st.button("Generate Prediction"):
        if cust_id_input in data.index:
            row = data.loc[cust_id_input]
            cust_features = pd.DataFrame([row[feature_cols]])
            
            pred_spend = model_spend.predict(cust_features)[0]
            pred_qty = model_qty.predict(cust_features)[0]
            
            # Logic: Visit Likelihood
            prob = row['MonthsActive'] / 10.0
            visit_likely = (prob >= 0.3 and pred_spend > 0)
            
            st.subheader(f"Results for Customer: {cust_id_input}")
            
            c1, c2 = st.columns(2)
            with c1:
                st.info(f"**Category:** {row['Category']}")
            with c2:
                if visit_likely: st.success("**Visit Likely?** YES ‚úÖ")
                else: st.error("**Visit Likely?** NO ‚ùå")

            c3, c4 = st.columns(2)
            c3.metric("Predicted Spend", f"${max(0, pred_spend):.2f}")
            c4.metric("Predicted Qty", f"{int(max(0, pred_qty))}")
            
            with st.expander("View History"):
                st.dataframe(row)
        else:
            st.warning("Customer ID not found.")
else:
    st.info("Please upload a file to begin.")
